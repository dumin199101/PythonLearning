#coding=utf-8
import gc
import sys
#小整数对象池[-5,256]之间常驻内存
#垃圾回收：引用计数，但是解决不了循环引用问题
#而在同一代码块执行时，当增加新的常量，会先在字典中查询记录，所以相同赋值的变量会指向同一个对象而不是新建对象。
#代码块作为一个执行单元，一个模块，一个函数体，一个类定义，一个脚本文件都是一个代码块，在交互式命令行中，每行代码视作一个代码块
#这就是为什么用命令行跟用脚本方式打印id结果不同的原因
#命令行下结果不同，但是脚本方式运行结果相同
#Ruby垃圾回收：标记清除 Python垃圾回收：引用计数为主，隔代回收为辅
A = 10000
B = 10000
print(id(A))
print(id(B))
del A
del B
C = 10000
print(id(C))

c = "hello world"
d = "hello world"
print(id(c))
print(id(d))

# 31100656
# 31100656
# 31100656
# 41023984
# 41023984
# gc.enable() #开启gc
# gc.disable() #关闭gc
# print(gc.get_count()) #获取当前自动执行垃圾回收的计数器,(488,3,0),
# 其中488是指距离上一次一代垃圾检查，Python分配内存的数目减去释放内存的数目,
# 3是指距离上一次二代垃圾检查，一代垃圾检查的次数，同理，0是指距离上一次三代垃圾检查，二代垃圾检查的次数
# print(gc.get_threshold()) #自动垃圾回收的阀值
# gc.garbage #垃圾回收列表
# gc.collect() #手动回收
print(sys.getrefcount(c)) #获取引用计数个数